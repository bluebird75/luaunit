--[[
static_checks.lua

This module does some static analysis of Lua code to detect the use of
undefined (global) variables.

It was inspired by http://lua-users.org/wiki/DetectingUndefinedVariables
Approach #2, and (as suggested) inspects the bytecode generated by the Lua
interpreter to detect any access to the global environment.

Author: NiteHawk <n1tehawk@users.noreply.github.com>
License: BSD License, see LICENSE.txt
]]
local M = {}

local LUA = arg[-1] or error ("FAILED to determine Lua interpreter path")
local lua_version = rawget(_G, "jit") and jit.version or _VERSION
local is_luajit = lua_version:match("^LuaJIT") ~= nil

local function printf(...)
	print(string.format(...))
end

--[[
Return process output (as a table of strings) and exit code. This is slightly
complicated by the fact that Lua io.popen() offers no simple way to retrieve
the exit code for Lua < 5.2. Try to work around that...
]]
local function poutput(command)
	command = command .. "; echo $?" -- so last output line should have exit code
	local output, pipe = {}, io.popen(command)
	for line in pipe:lines() do
		table.insert(output, line)
	end
	pipe:close()

	local exit_code
	if tonumber(output[#output]) then
		exit_code = tonumber(output[#output]) -- retrieve exit code...
		output[#output] = nil -- ...and strip last line
	end
	if exit_code ~= 0 then
		printf('ERROR executing "%s", exit code %d', command, exit_code)
	end

	return output, exit_code
end

local STANDARD_GLOBALS = {
	"_G",
	"_VERSION",
	"arg",
	"assert",
	"coroutine",
	"debug",
	"error",
	"io",
	"ipairs",
	"jit", -- (LuaJIT only)
	"math",
	"next",
	"os",
	"package",
	"pairs",
	"pcall",
	"print",
	"rawget",
	"require",
	"setmetatable",
	"string",
	"table",
	"tonumber",
	"tostring",
	"type",
	"xpcall",
}

local function validate_global_get(name, scope, allowed_globals)
	for _, allowed in ipairs(STANDARD_GLOBALS) do
		if name == allowed then
			return true
		end
	end
	for _, allowed in ipairs(allowed_globals or {}) do
		if name:match("^" .. allowed .. "$") then
			return true
		end
	end
	printf('global GET "%s" (%s)', name, scope)
	return false
end

local function validate_global_set(name, scope, allowed_globals)
	for _, allowed in pairs(allowed_globals or {}) do
		if name:match("^" .. allowed .. "$") then
			return true
		end
	end
	printf('global SET "%s" (%s)', name, scope)
	return false
end

--[[
Examine the given Lua file for usage of global variables. Optional parameters:
"allowed_globals" is a table of string patterns (variable names) that will be
accepted; if "strict" evaluates to `true`, the function will also check global
GETs (otherwise only SETs are considered).
Returns the number of problems (= undefined variable access) detected.
]]
function M.check_globals(filename, allowed_globals, strict)
	-- construct a command to list the bytecode representation of filename
	local command
	if is_luajit then
		command = LUA .. " -bl " .. filename
	else
		-- assume standard Lua, and require the interpreter to end on "lua"
		assert(LUA:match("lua$"))
		-- with that passed, append a 'c' character to get the "luac" compiler
		command = LUA .. "c -p -l " .. filename
	end

	-- patterns to match retrieving (GET) and assigning (SET) globals
	local pattern_GET, pattern_SET
	if is_luajit then
		pattern_GET = 'GGET.*; "([%w_]+)"'
		pattern_SET = 'GSET.*; "([%w_]+)"'
	elseif lua_version == "Lua 5.1" then
		pattern_GET = 'GETGLOBAL.*; ([%w_]+)'
		pattern_SET = 'SETGLOBAL.*; ([%w_]+)'
	else
		-- assume Lua 5.2+ - globals are handles as "upvalues" from _ENV
		pattern_GET = 'GETTABUP.*; _ENV "([%w_]+)"'
		pattern_SET = 'SETTABUP.*; _ENV "([%w_]+)"'
	end

	local output, exit_code = poutput(command)
	if exit_code ~= 0 then
		return exit_code
	end

	local scope, problems = "<unknown>", 0
	for _, line in ipairs(output) do
		if is_luajit then
			if line:find("-- BYTECODE -- ", 1, true) == 1 then
				scope = line:sub(16)
			end
		else
			scope = table.concat({filename, line:match("^%s*%d+%s*%[(%d+)%]")}, ':')
		end

		local name = line:match(pattern_GET)
		if name and strict then
			if not(validate_global_get(name, scope, allowed_globals)) then
				problems = problems + 1
			end
		else
			name = line:match(pattern_SET)
			if name and not(validate_global_set(name, scope, allowed_globals)) then
				problems = problems + 1
			end
		end
	end
	return problems
end

return M
